<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' unpkg.com www.googletagmanager.com *.google-analytics.com; img-src 'self' data: *;style-src 'self' 'unsafe-inline'">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<link rel="canonical" href="https://blog.jermdavis.dev/posts/2016/a-thought-experiment-in-text-parsing">
		<meta name="description" content="Every so often, every developer finds themselves having to parse data out of text. There are loads of ways of approaching this task, but a lot of pretty unsatisfactory solutions start from &quot;I'll just split up the text by whitespace&quot; or &quot;Hey, let's use regular expressions!&quot;. You all <a href=&quot;http://regex.info/blog/2006-09-15/247&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;>remember what regular expressions lead to, right</a>?
As someone who's always on the lookout for something interesting and new to experiment with, I came across an alternative approach to parsing text recently. A blog post I read (I forget what it was, or I'd give credit) linked to the <a href=&quot;https://github.com/sprache/Sprache&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;>Sprache project on GitHub</a>. This is a text parsing library which lets you construct the descriptions of the text to parse using Linq-style expressions.
So I thought I'd invent an idea for an experimental project to test this out...">
		<meta property="og:description" content="Every so often, every developer finds themselves having to parse data out of text. There are loads of ways of approaching this task, but a lot of pretty unsatisfactory solutions start from &quot;I'll just split up the text by whitespace&quot; or &quot;Hey, let's use regular expressions!&quot;. You all <a href=&quot;http://regex.info/blog/2006-09-15/247&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;>remember what regular expressions lead to, right</a>?
As someone who's always on the lookout for something interesting and new to experiment with, I came across an alternative approach to parsing text recently. A blog post I read (I forget what it was, or I'd give credit) linked to the <a href=&quot;https://github.com/sprache/Sprache&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;>Sprache project on GitHub</a>. This is a text parsing library which lets you construct the descriptions of the text to parse using Linq-style expressions.
So I thought I'd invent an idea for an experimental project to test this out...">
		<meta name="keywords" content="FakeDB, Sitecore, Sprache, Unit Test">
		<meta name="author" content="Jeremy Davis">
		<meta name="copyright" content="Jeremy Davis">
		<title>Jeremy Davis - A thought experiment in text&nbsp;parsing</title>
		<meta name="robots" content="index, follow">
		<link type="application/rss+xml" rel="alternate" title="Jeremy Davis - Sitecore, C# and web development" href="/feed.rss">
		<link type="application/atom+xml" rel="alternate" title="Jeremy Davis - Sitecore, C# and web development" href="/feed.atom">
		<meta name="application-name" content="Jeremy Davis">
		<meta name="msapplication-tooltip" content="Jeremy Davis">
		<meta name="msapplication-starturl" content="/">
		<link rel="manifest" href="/manifest.webmanifest">
		<meta property="og:type" content="article">
		<meta property="og:title" content="A thought experiment in text&nbsp;parsing [by Jeremy Davis]">
		<meta property="og:publish_date" content="2016-06-27T00:00:00+0000">
		<meta property="article:published_time" content="2016-06-27T00:00:00+0000">
		<meta property="og:modified_date" content="2016-08-25T00:00:00+0000">
		<meta property="article:modified_time" content="2016-08-25T00:00:00+0000">
		<meta property="og:image" content="https://blog.jermdavis.dev/img/featured/a-thought-experiment-in-text-parsing-social.jpg">
		<meta property="og:image:alt" content="Logo image showing post title 'A thought experiment in text&nbsp;parsing' and author 'Jeremy Davis'">
		<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "article",
        "headline": "A thought experiment in text parsing",
        "url": "https://blog.jermdavis.dev/posts/2016/a-thought-experiment-in-text-parsing",
        "image": [
            {
                "@type": "ImageObject",
                "contentUrl": "https://blog.jermdavis.dev/img/featured/a-thought-experiment-in-text-parsing-social.jpg",
                "caption": "Logo image showing post title 'A thought experiment in text parsing' and author 'Jeremy Davis'"
            }
        ],
        "datePublished": "2016-06-27T00:00:00+0000",
        "dateModified": "2016-08-25T00:00:00+0000",
        "author": [{
            "@type": "Person",
            "name": "Jeremy Davis",
            "url": "https://jermdavis.dev/"
        }]
    }
    
		</script>
		<meta property="og:url" content="https://blog.jermdavis.dev/posts/2016/a-thought-experiment-in-text-parsing">
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">
		<link href="/scss/tailwind.css" rel="stylesheet">
		<link href="/vendor/Enlighter/enlighterjs.min.css" rel="stylesheet">
		<link href="/scss/site-theme.css" rel="stylesheet">
		<script src="/vendor/Cookies/cookies.min.js" defer=""></script>
	</head>
	<body class="max-w-7xl mx-auto text-black" id="top">
		<div id="rp-bar"></div>
		<div class="relative bg-white" x-data="{ open: false }">
			
			<!-- desktop -->
			<div class="px-4 lg:px-6 bg-gray-100">
				<div class="bannerContainer flex justify-between items-center border-b-2 border-gray-100 py-6 lg:justify-start lg:space-x-10">
					<div class="flex justify-start lg:w-0 flex-1">
						<a href="/">
							<img class="mt-2" width="56" height="56" src="/img/Profile.jpg" alt="Jeremy Davis">
						</a>
						<div class="mx-2">
							<div class="text-3xl">Jeremy Davis</div>
							<div class="text-lg">Sitecore, C# and web development</div>
						</div>
					</div>
					<div class="nav -mr-2 -my-2 lg:hidden">
						<button @click="open = true" type="button" class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" aria-expanded="false">
							<span class="sr-only">Open menu</span>
							
							<!-- Heroicon name: outline/menu -->
							<svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
							</svg>
						</button>
					</div>
					<nav class="nav hidden lg:flex space-x-10">
						<a class="text-base font-medium" href="/posts">Posts</a>
						<a class="text-base font-medium" href="/tags">Tags</a>
						<a class="text-base font-medium" href="/about">About</a>
						<a class="text-base font-medium" href="/links">Useful Links</a>
						<a class="text-base font-medium" href="/mvp">MVP</a>
					</nav>
				</div>
			</div>
			
			<!--Mobile menu, show/hide based on mobile menu state.-->
			<div class="absolute top-0 inset-x-0 p-2 transition transform origin-top-right lg:hidden z-50">
				<div style="display:none;" class="rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 bg-white divide-y-2 divide-gray-50" x-show="open" x-transition="">
					<div class="pt-5 pb-6 px-5">
						<div class="flex items-center justify-between">
							<div class="flex">
								<a href="/">
									<img class="mt-2" width="56" height="56" src="/img/Profile.jpg" alt="Jeremy Davis">
								</a>
								<div class="mx-2">
									<div class="text-2xl">Jeremy Davis</div>
									<div class="text-base">Sitecore, C# and web development</div>
								</div>
							</div>
							<div class="nav -mr-2">
								<button @click="open = false" type="button" class="bg-white rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500">
									<span class="sr-only">Close menu</span>
									
									<!-- Heroicon name: outline/x -->
									<svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
									</svg>
								</button>
							</div>
						</div>
					</div>
					<div class="nav py-6 px-5 pt-0">
						<nav class=" gap-x-8">
							<a class="block mt-5 text-base font-medium" href="/posts">Posts</a>
							<a class="block mt-5 text-base font-medium" href="/tags">Tags</a>
							<a class="block mt-5 text-base font-medium" href="/about">About</a>
							<a class="block mt-5 text-base font-medium" href="/links">Useful Links</a>
							<a class="block mt-5 text-base font-medium" href="/mvp">MVP</a>
						</nav>
					</div>
				</div>
			</div>
		</div>
		<header class="bg-gray-300 px-4 py-1 lg:px-6 text-center" style="">
			<div class="post-heading">
				<div class="url p-1 bg-gray-100 rounded-md">Article printed from:
					<tt>https://blog.jermdavis.dev/posts/2016/a-thought-experiment-in-text-parsing</tt>
				</div>
				<h1 class="text-5xl mb-4 pb-1">
					A thought experiment in text&nbsp;parsing
				</h1>
				<div class="meta">Published 27 June 2016</div>
				<div class="meta">Updated 25 August 2016</div>
				<div class="flex py-1 flex-wrap">
					<a href="/tags/fakedb/" class="p-1 mr-1 mt-1 bg-gray-100 rounded-md whitespace-nowrap">
						FakeDB</a>
					<a href="/tags/sitecore/" class="p-1 mr-1 mt-1 bg-gray-100 rounded-md whitespace-nowrap">
						Sitecore</a>
					<a href="/tags/sprache/" class="p-1 mr-1 mt-1 bg-gray-100 rounded-md whitespace-nowrap">
						Sprache</a>
					<a href="/tags/unit-test/" class="p-1 mr-1 mt-1 bg-gray-100 rounded-md whitespace-nowrap">
						Unit Test</a>
					<span class="p-1 mr-1 mt-1 bg-gray-100 rounded-md whitespace-nowrap">~8 min. read</span>
				</div>
			</div>
		</header>
		<div class="py-2 lg:pl-3">
			<div class="lg:flex">
				<div class="lg:flex-auto mx-3 lg:min-w-0 content">
					<p>Every so often, every developer finds themselves having to parse data out of text. There are loads of ways of approaching this task, but a lot of pretty unsatisfactory solutions start from "I'll just split up the text by whitespace" or "Hey, let's use regular expressions!". You all
						<a href="http://regex.info/blog/2006-09-15/247" target="_blank" rel="noopener noreferrer">remember what regular expressions lead to, right</a>?</p>
					<p>As someone who's always on the lookout for something interesting and new to experiment with, I came across an alternative approach to parsing text recently. A blog post I read (I forget what it was, or I'd give credit) linked to the
						<a href="https://github.com/sprache/Sprache" target="_blank" rel="noopener noreferrer">Sprache project on GitHub</a>. This is a text parsing library which lets you construct the descriptions of the text to parse using Linq-style expressions.</p>
					<p>So I thought I'd invent an idea for an experimental project to test this out...
						<!--more-->
					</p>
					<h2>What was the idea?</h2>
					<p>Imagine your client phones you up one day and says "Our SEO people have sent me a text file full of changes we should make to the structure of our content. We need you to implement all the changes right away!". Not a million miles from something that might happen in reality... You could make all the changes by hand, or maybe you could automate them? Well the right answer is almost certainly
						<a href="https://marketplace.sitecore.net/en/Modules/Sitecore_PowerShell_console.aspx" target="_blank" rel="noopener noreferrer">something involving PowerShell Extensions</a>, but for the purposes of having an excuse to learn about Sprache, how about this:</p>
					<p>Lets assume there are three operations described in the text file, and that the SEO people were nice enough to use a standard pattern for each one:</p>
					<ul>
						<li>
							<p>
								<strong>Delete an item</strong>
							</p>
							<p>
								<code>delete &lt;item&gt;</code>
							</p>
						</li>
						<li>
							<p>
								<strong>Move an item</strong>
							</p>
							<p>
								<code>move &lt;item&gt; to &lt;location&gt;</code>
							</p>
						</li>
						<p></p>
						<li>
							<p>
								<strong>Create an item</strong>
							</p>
							<p>
								<code>create &lt;template&gt; named &lt;name&gt; under &lt;location&gt; [with &lt;fieldName&gt;="&lt;value&gt;"[,etc]]</code>
							</p>
						</li>
					</ul>
					<p>What we'd like our automation to do is take a list of these commands from some text, and then attempt to process each one in turn. What code do we need to achieve that?</p>
					<h2>First job: Parsing an item or path to operate on</h2>
					<p>Taking a TDD type approach to this, what are the initial tests we might want for parsing a delete command? Well looking at the example above we need to parse the "delete" operation and we need to parse out the defintion of an item to delete. Sitecore usually identifies items by paths or IDs, so that tends to suggest we need to be able to parse either a path or a GUID here.</p>
					<p>As you might expect from native .Net code, Sprache is a strongly typed parser. So if we're going to want to parse a "GUID or Path" field, we need to be able to parse the text into a type holding this data. A test case might look like this for GUIDs:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">[TestMethod]
public void ItemIDParsesValidID()
{
    string guid = "{582ccf36-b6e4-49f0-9c35-2d8e40b5ef3d}";
    var result = CommandTextParser.ItemId.TryParse(guid);

    Assert.IsTrue(result.WasSuccessful, result.Message);
    Assert.AreEqual(Guid.Parse(guid), result.Value.Id);
    Assert.AreEqual(string.Empty, result.Value.Path);
}

					</pre>
					<p>Or this for paths:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public void ItemPathParsesForValidPath()
{
    string path = "/alpha/bravo";

    var result = CommandTextParser.ItemPath.TryParse(path);

    Assert.IsTrue(result.WasSuccessful, result.Message);
    Assert.AreEqual(path, result.Value.Path);
    Assert.AreEqual(Guid.Empty, result.Value.Id);
}

					</pre>
					<p>So what code do we need to make these tests pass? Well, Sprache tends to have its parsing methods defined as statics to allow composing them easily. So we'll need a static class to hold our parsing code, and it's going to need our "ItemPath" parser from the test above:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static class CommandTextParser
{
    public static Parser&lt;ItemIdenitfier&gt; PathOrID = ??
}

					</pre>
					<p>And we're going to need that class our test implies to encapsulate our output:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class ItemIdenitfier
{
    public string Path { get; set; }
    public Guid Id { get; set; }
}

					</pre>
					<p>So with the boilerplate out of the way, what do we actually want to do with the parsing? In English, we want to parse "A path, or a GUID, and maybe any surrounding whitespace". Sprache makes that pretty easy to express, because you can build more complex expressions out of simpler ones:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static class CommandTextParser
{
    public static Parser&lt;ItemIdenitfier&gt; PathOrID =
        ItemPath
        .XOr(ItemId)
        .Token();
}

					</pre>
					<p>We'll get to defining the "ItemPath" and "ItemID" parser code in a bit. This expression just uses an exclusive Or to bind them together – so says "one or the other, but never both" and the
						<code>Token()</code>
						method is shorthand for telling Sprache "ignore any surrounding whitespace".</p>
					<p>The Item ID parser is the simpler of the two, so lets start with that. A simplestic definition of a GUID is "an opening curly brace, followed by a string of letters, numbers or hyphens, and ending with a closing curly brace". That's not a particularly rigerous definition – but we can live with that for the moment. A parser for that can be written as:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ItemIdenitfier&gt; ItemId =
    from openBrace in Parse.Char('{')
    from id in Parse.LetterOrDigit.Or(Parse.Char('-')).Repeat(36).Text()
    from closeBrase in Parse.Char('}')
    select new ItemIdenitfier() { Path = string.Empty, Id = Guid.Parse(id) };

					</pre>
					<p>This uses Linq syntax to find specific things and assign them to local variables. First we find the open curly, then we find the body of the GUID, followed by the closing curly brace. The body is a run of 36 characters, each of which can be only a letter, a digit or a hyphen. The final
						<code>Text()</code>
						method turns the
						<code>IEnumerable&lt;char&gt;</code>
						returned by the
						<code>Repeat()</code>
						into a string. Then finally we use the local variables we captured to populate one of our
						<code>ItemIdentifier</code>
						objects to return.</p>
					<p>You could write a more rigerous version of this that makes sure that the right pattern of characters and dashes is presented - but I'll leave that as an exercise to the reader...</p>
					<p>It's way more readable than the equivalent regular expression, eh?</p>
					<p>Parsing a path could be done by saying "A path is any string made up of slashes and valid item name characters" but that probably allows paths with double slashes, which don't seem relevant to a Sitecore solution. Instead, the definition is probably that a path is "One or more sets of ‘A slash followed by some valid item name characters'". Following the pattern of building up complex behaviour from simpler parsers, we can define an item name as:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static IEnumerable&lt;char&gt; InvalidNameCharacters = new List&lt;char&gt; { '\\', '/', ':', '?', '"', '&lt;', '&gt;', '|', '[', ']', ' ', '!', '(', ')', '%', '#', '@', '!', '£', '$', '^', '&amp;', ';', '~' };

public static Parser&lt;string&gt; ItemName =
    Parse.CharExcept(InvalidNameCharacters).AtLeastOnce().Text().Token();

					</pre>
					<p>We declare a set of characters that aren't valid in names (your ideal set may vary – that's just an example) and we say that a name is "a string containing anything but these characters".</p>
					<p>From there, we can say that one segment of a path is a slash followed by a name:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;string&gt; PathSegment =
    from slash in Parse.Chars(new char[] { '\\', '/' })
    from name in ItemName
    select name;

					</pre>
					<p>And then we can define an entire path in the following form:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ItemIdenitfier&gt; ItemPath =
    from parts in (
        from firstSegment in PathSegment
        from otherSegments in PathSegment.Many()
        select firstSegment.Concatenate(otherSegments)
    )
    from trailingSlash in Parse.Char('\\').Optional()
    select new ItemIdenitfier() { Id=Guid.Empty, Path = "/" + string.Join("/", parts) };

					</pre>
					<p>This says "First match one path segment. Then optionally match many more path segments" and it then returns a list of the names in the path segments found. Optionally there may be a trailing slash on the end of the whole thing. And the result of the parsing is an
						<code>ItemIdentifier</code>
						where the
						<code>Path</code>
						is buit up by joining those item names back together again.</p>
					<p>And with that code in place, the two tests defined above should now pass.</p>
					<h2>Building on that to parse the delete operation</h2>
					<p>Now we can parse a path, we can move on to parsing the delete operation. We're going to want a different output from the parser here – we're going to need a class to represent a deletion. However, in the future we're going to want to create a single parsing method that can parse any of our three commands – so the delete command parser will need to be defined in terms of a more generic "any command" type. To me this smells like a situation for the Command pattern, as later we're going to need this class to know how to process the deletion.</p>
					<p>So we can define a Commmand pattern interface:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public interface ICommand
{
    string Execute();
}

					</pre>
					<p>And we can then define our delete command object in terms of that:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class DeleteCommand : ICommand
{
    public ItemIdenitfier Item { get; set; }

    public string Execute()
    {
        // fill this in later
    }
}

					</pre>
					<p>Parsing the data for that is now pretty easy:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ICommand&gt; DeleteCommand =
    from cmd in Parse.IgnoreCase("delete").Token()
    from item in PathOrID
    select new DeleteCommand() { Item = item };

					</pre>
					<p>The command always starts with "delete" and we don't care about case or white space. And it's always followed by an identifier which might be a GUID or a path. From there we can return a
						<code>DeleteCommand</code>
						with that item in it, ready for processing...</p>
					<p>And we can check this with some further tests. Things like:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">[TestMethod]
public void DeleteParsesWithPath()
{
    var result = CommandTextParser.DeleteCommand.TryParse(@"delete \abc\def\x");

    Assert.IsTrue(result.WasSuccessful, result.Message);

    var cmd = result.Value as DeleteCommand;

    Assert.AreEqual("/abc/def/x", cmd.Item.Path);
}

[TestMethod]
public void DeleteParsesWithID()
{
    var result = CommandTextParser.DeleteCommand.TryParse(@"delete {7f700de5-9f24-4a30-a4f7-ed3421abb563}");

    Assert.IsTrue(result.WasSuccessful, result.Message);

    var cmd = result.Value as DeleteCommand;

    Assert.AreEqual(Guid.Parse("{7f700de5-9f24-4a30-a4f7-ed3421abb563}"), cmd.Item.Id);
}

					</pre>
					<p>And with all the code above in place these will pass too.</p>
					<h2>Now to actually delete...</h2>
					<p>Writing code in Sitecore to delete an item isn't hard – but sticking to our pattern of having tests to validate the code is less easy. Our saviour here comes in the form of the
						<a href="https://github.com/sergeyshushlyapin/Sitecore.FakeDb" target="_blank" rel="noopener noreferrer">Sitecore.FakeDb project</a>. This allows you to run an "in-RAM" version of the Sitecore data APIs in your test project.</p>
					<p>It's very easy to install: All you need is the NuGet package added to your test project, a few DLLs from a valid Sitecore install (which can't go in NuGet for licensing reasons) and your Sitecore license file.</p>
					<p>Once you have that in place, you're free to write tests against Sitecore item data like this:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">[TestMethod]
public void ValidDeleteWorks()
{
    CommandProcessor cp = new CommandProcessor();
    using (Db db = new Db())
    {
        var f1 = new DbItem("Folder1");
        var p1 = new DbItem("Page");
        f1.Add(p1);
        db.Add(f1);

        Assert.AreEqual(1, f1.Children.Count);

        DeleteCommand cmd = new DeleteCommand();
        cmd.Item = new ItemIdenitfier() { Path="/sitecore/content/Folder1/Page" };

        var result = cmd.Execute();

        Assert.IsTrue(result.StartsWith("deleted", StringComparison.InvariantCultureIgnoreCase));
        Assert.AreEqual(0, f1.Children.Count);
    }
}

					</pre>
					<p>It creates an instance of the "fake" database and then adds a folder containing an item. It creates a
						<code>DeleteCommand</code>
						which specifies the item under the test folder, and then it runs the command.</p>
					<p>What do we need to make that test pass? Just the implementation of the
						<code>Execute()</code>
						method from our Command pattern above. Something like:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class DeleteCommand : ICommand
{
    public ItemIdenitfier Item { get; set; }

    public string Execute()
    {
        var itm = Sitecore.Context.Database.GetItem(Item.ToString());
        if (itm == null)
        {
            throw new ArgumentException("The item " + Item.ToString() + " was not found", "cmd.Item");
        }

        itm.Delete();

        return "Deleted " + Item.ToString();
    }
}

					</pre>
					<p>Note how the code can refer to
						<code>Sitecore.Context.Database</code>
						and FakeDb magically replaces that with the in-memory database for the purposes of this test.</p>
					<p>Easy, huh?</p>
					<h2>Moving items</h2>
					<p>Creating the move command is pretty similar - it just needs to parse out two item identifiers because you need the item and the target folder:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ICommand&gt; MoveCommand =
    from cmd in Parse.IgnoreCase("move").Token()
    from item in PathOrID
    from to in Parse.IgnoreCase("to").Token()
    from newLocation in PathOrID
    select new MoveCommand() { Item = item, NewLocation = newLocation };

					</pre>
					<p>And the
						<code>MoveCommand</code>
						class is similarly easy:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class MoveCommand : ICommand
{
    public ItemIdenitfier Item { get; set; }
    public ItemIdenitfier NewLocation { get; set; }

    public string Execute()
    {
        var folder = Sitecore.Context.Database.GetItem(NewLocation.ToString());
        if (folder == null)
        {
            throw new ArgumentException("The item " + NewLocation.ToString() + " was not found", "cmd.NewLocation");
        }

        var item = Sitecore.Context.Database.GetItem(Item.ToString());
        if (item == null)
        {
            throw new ArgumentException("The item " + Item.ToString() + " was not found", "cmd.Item");
        }

        item.MoveTo(folder);

        return "Moved " + Item.ToString();
    }
}

					</pre>
					<p>Again we can write tests to validate both of these. (More of that later)</p>
					<h2>Creating items</h2>
					<p>The create command is a bit more complex. It needs to parse out a template identifer, a location and a name. Then it has to optionally parse any other field values that need setting. The parsing code for that is a bit more complex:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ICommand&gt; CreateCommand =
    from cmd in Parse.IgnoreCase("create").Token()
    from template in PathOrID
    from named in Parse.IgnoreCase("named").Token()
    from itemName in ItemName.Token()
    from under in Parse.IgnoreCase("under").Token()
    from location in PathOrID
    from fieldValues in (
        from with in Parse.IgnoreCase("with").Token()
        from fields in (
            from first in Field
            from rest in Parse.Char(',').Token().Then(_ =&gt; Field).Many()
            select first.Concatenate(rest))
        select fields
        ).Optional()
    select new CreateCommand() { Template = template, Name = itemName, Location = location, Fields = fieldValues.GetOrElse(new List&lt;Field&gt;()) };

					</pre>
					<p>The first few bits, which parse out the type of command, the template, the name and path are all much as before. The more complex bit comes from parsing the optional set of field values.</p>
					<p>Firstly, the
						<code>from</code>
						clause for the "with name=value[,etc]" part of the command is wraped up with a
						<code>Optional()</code>
						method to mark that this whole part of the command may not be there.</p>
					<p>Within that, it repeats the "one or more of something" pattern of parsing out the first field value, followed by zero or more of "a comma, then another field". And then it pulls together all of the field definitions into a list, which is used in the
						<code>select</code>
						clause to initialise the
						<code>CreateCommand</code>. Note the use of the
						<code>GetOrElse()</code>
						extension method. This says "if fieldValues is null, return an empty list of fields instead". This is required because if the parser used the
						<code>Optional()</code>
						clause mentioned above then it will not intialise the
						<code>fieldValues</code>
						object. This is an easy pattern to use in these Linq-style expressions - but
						<a href="/posts/2015/when-is-a-reference-to-null-not-a-null-reference" target="_blank">take care that this "method call on a potentially null object" pattern can confuse people sometimes</a>.</p>
					<p>The
						<code>Field</code>
						parser needs to deal with two different scenarios. It has to be able to parse a
						<code>FieldName="value</code>
						string where there are no spaces in the name of the field. But some fields do have spaces, hence it needs to be able to parse a quoted field name in the format
						<code>Field Name"="value</code>
						too. As above, we can do that by building up smaller parsers:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;string&gt; QuotedFieldName =
    from openQuote in Parse.Char('"')
    from value in Parse.CharExcept('"').Many().Text()
    from closeQuote in Parse.Char('"')
    select value;

public static Parser&lt;string&gt; UnquotedFieldName =
    from name in Parse.CharExcept(new char[] { '=', ' ' }).Many().Text()
    select name;

public static Parser&lt;Field&gt; Field =
    from name in QuotedFieldName.XOr(UnquotedFieldName)
    from equalSign in Parse.Char('=').Token()
    from openQuote in Parse.Char('"')
    from value in Parse.CharExcept('"').Many().Text()
    from closeQuote in Parse.Char('"') 
    select new Field() { Name = name, Value = value };

					</pre>
					<p>The
						<code>Field</code>
						type here just stores name / value pair to describe the field:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class Field
{
    public string Name { get; set; }
    public string Value { get; set; }
}

					</pre>
					<p>The
						<code>CreateCommand</code>
						class follows the same patterns as the other commands, but it's a bit more complex:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public class CreateCommand : ICommand
{
    public ItemIdenitfier Template { get; set; }
    public string Name { get; set; }
    public ItemIdenitfier Location { get; set; }
    public IEnumerable&lt;Field&gt; Fields { get; set; }

    public string Execute()
    {
        TemplateID tid;
        if (Template.Id != Guid.Empty)
        {
            tid = new TemplateID(new ID(Template.Id));
        }
        else
        {
            var ti = Sitecore.Context.Database.GetTemplate(Template.Path);
            tid = new TemplateID(ti.ID);
        }

        var folder = Sitecore.Context.Database.GetItem(Location.ToString());
        if (folder == null)
        {
            throw new ArgumentException("The item " + Location.ToString() + " was not found", "cmd.Location");
        }

        var item = folder.Add(Name, tid);

        if (Fields != null)
        {
            item.Editing.BeginEdit();
            foreach (var field in Fields)
            {
                item[field.Name] = field.Value;
            }
            item.Editing.EndEdit();
        }

        return "Created " + item.Paths.Path;
    }
}

					</pre>
					<p>And as before, tests can run against all these bits of code to verify they work correctly...</p>
					<h2>Finally, parse any command</h2>
					<p>Now we've got parsers for each of the individual commands, it's trivial to parse "any command":</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">public static Parser&lt;ICommand&gt; Any =
    CreateCommand
    .XOr(MoveCommand)
    .XOr(DeleteCommand);

					</pre>
					<p>Any string it parses must match exactly one of our command parsers. And you can write tests to validate this works correctly, like:</p>
					<pre class="code" data-enlighter-language="csharp" style="width:100%; overflow:scroll;">[TestMethod]
public void AnyCanParseCreate()
{
    var result = CommandTextParser.Any.TryParse("create \\12 named alpha under {582ccf36-b6e4-49f0-9c35-2d8e40b5ef3d} with a=\"2\"");

    Assert.IsTrue(result.WasSuccessful, result.Message);
    Assert.IsInstanceOfType(result.Value, typeof(CreateCommand));

    var cmd = result.Value as CreateCommand;

    Assert.AreEqual("/12", cmd.Template.Path);
    Assert.AreEqual(Guid.Parse("582ccf36-b6e4-49f0-9c35-2d8e40b5ef3d"), cmd.Location.Id);
    Assert.AreEqual("alpha", cmd.Name);
    Assert.AreEqual(1, cmd.Fields.Count());
    Assert.AreEqual("a", cmd.Fields.First().Name);
}

					</pre>
					<h2>Wrapping up...</h2>
					<p>That was the point at which I figured I'd got as much learning out of this example as I could, and moved on to other things.</p>
					<p>It's a contrived example, but hopefully it shows that when you do need to parse text into structured data, there are better choices than Regular Expressions for C# developers. While I'll admit that working out how to use the Sprache API can be a bit challenging to begin with, the end result is much more usable, testable and readable than anything a regex will give you. And as a side effect, hopefully the code shows just how easy and helpful the Sitecore.FakeDb project is for enabling unit test of your API-level code.</p>
					<p>In case you're interested in running the tests yourself, or delving through this code in more detail, I've
						<a href="https://github.com/jermdavis/SpracheBlog" target="_blank" rel="noopener noreferrer">posted the whole test project to GitHub</a>. Feel free to clone and mess about...</p>
					<a class="gotop" href="#top">↑ Back to top</a>
				</div>
				<div class="sidebar lg:flex-none lg:w-64 m-0 mt-1 lg:mt-0 lg:p-1 lg:bg-gray-100">
					<div class="md:flex-row md:flex lg:flex-col">
						<section class="md:flex-2 md:flex-grow md:flex-shrink">
							<h3 class="bg-gray-300 p-2 md:border-r-2 md:border-white lg:border-r-0">Top Tags</h3>
							<div class="bg-white p-2 flex flex-wrap">
								<a href="/tags/sitecore/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Sitecore (229)</a>
								<a href="/tags/c/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									C# (61)</a>
								<a href="/tags/powershell/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									PowerShell (31)</a>
								<a href="/tags/installation/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Installation (23)</a>
								<a href="/tags/solr/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Solr (19)</a>
								<a href="/tags/general/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									General (17)</a>
								<a href="/tags/docker/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Docker (17)</a>
								<a href="/tags/containers/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Containers (16)</a>
								<a href="/tags/ui/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									UI (15)</a>
								<a href="/tags/bug/" class="flex-initial text-lg p-1 mr-1 bg-gray-100 rounded-md mt-1">
									Bug (12)</a>
							</div>
							<div class="bg-white mb-2 p-2">
								<a class="text-lg" href="/tags" role="button">All Tags
									<i class="fas fa-angle-double-right"></i>
								</a>
							</div>
						</section>
						<section class="md:flex-2 md:border-l-2 md:border-gray-300 lg:border-l-0 md:flex-shrink-0">
							<h3 class="bg-gray-300 p-2 md:border-r-2 md:border-white lg:border-r-0">Recent Months</h3>
							<div class="bg-white p-2">
								<div>
									<a class="text-lg" href="/posts/2024-06">2024 - June</a>
								</div>
								<div>
									<a class="text-lg" href="/posts/2024-05">2024 - May</a>
								</div>
								<div>
									<a class="text-lg" href="/posts/2024-04">2024 - April</a>
								</div>
								<div>
									<a class="text-lg" href="/posts/2024-03">2024 - March</a>
								</div>
								<div>
									<a class="text-lg" href="/posts/2024-02">2024 - February</a>
								</div>
							</div>
							<div class="bg-white mb-2 p-2">
								<a class="text-lg" href="/posts" role="button">All Posts
									<i class="fas fa-angle-double-right"></i>
								</a>
							</div>
						</section>
						<section class="md:flex-1 md:border-l-2 md:border-gray-300 lg:border-l-0 md:flex-shrink">
							<h3 class="bg-gray-300 p-2 md:border-r-2 md:border-white lg:border-r-0">Socials</h3>
							<div class="bg-white mb-2 p-2">
								<div>
									<a class="text-lg" rel="me" target="_blank" href="https://mastodon.social/@jermdavis">Mastodon</a>
								</div>
								<div>
									<a class="text-lg" rel="me" target="_blank" href="https://bsky.app/profile/jermdavis.dev">Bluesky</a>
								</div>
								<div>
									<a class="text-lg" rel="me" target="_blank" href="https://www.linkedin.com/in/djdavis/">LinkedIn</a>
								</div>
							</div>
						</section>
						<section class="mvp md:flex-2 md:border-l-2 md:border-gray-300 lg:border-l-0 md:flex-shrink-0 lg:order-first">
							<h3 class="bg-gray-300 p-2">Sitecore MVP 2015-2024</h3>
							<div class="bg-white mb-2 p-2">
								<a href="/mvp">
									<img class="lg:mx-auto" src="/img/mvp/10yrs.png" width="219" height="219" alt="2024 MVP Badge">
								</a>
							</div>
						</section>
					</div>
				</div>
			</div>
		</div>
		<footer class="lg:flex order-1 bg-gray-100 px-4 lg:px-6 py-4">
			<div class="flex-1 lg:flex-1 text-center lg:text-left">
				<div>©
					<a target="_blank" class="font-medium" rel="noopener" href="https://jermdavis.dev/">Jeremy Davis</a>
					2014-2024</div>
			</div>
			<div class="lg:flex-1 lg:order-3 text-center lg:text-right">
				<a class="font-medium" href="/tools">Published using Statiq</a>
				<br>
			</div>
			<ul class="list-none lg:flex-1 lg:order-2 p-0 text-center lg:align-middle" style="margin:0px !important">
				<li class="inline-block">
					<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18 0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
					</svg>
				</li>
				<li class="inline-block ml-4">
					<a class="font-medium" target="_blank" href="/feed.rss">RSS</a>
				</li>
				<li class="inline-block ml-4">
					<a class="font-medium" target="_blank" href="/feed.atom">Atom</a>
				</li>
			</ul>
		</footer>
		<div class="min-h-screen bg-gray-300 py-6 flex flex-col justify-center sm:py-12" x-data="{ hide_banner: true }" x-init="hide_banner = docCookies.hasItem('hide_banner');" x-bind:class="{ 'hidden': hide_banner, 'fixed': !hide_banner }">
			<div class="border-2 border-gray-600 bg-gray-100 max-w-screen-lg mx-auto fixed bg-white inset-x-5 p-5 bottom-10 rounded-lg drop-shadow-2xl flex gap-4 flex-wrap md:flex-nowrap text-center md:text-left items-center justify-center md:justify-between">
				<div class="w-full text-lg">
					<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/cookie-usage" rel="noreferrer" target="_blank">This website uses Google Analytics, and its cookies.</a>
				</div>
				<button type="button" @click="hide_banner = true; docCookies.setItem('hide_banner', true, 'Fri, 31 Dec 9999 23:59:59 GMT', null, null, null, 'strict');" class="bg-gray-400 px-5 py-2 text-white rounded-md hover:bg-gray-600 focus:outline-none" aria-label="Dismiss">Understood</button>
			</div>
		</div>
		<script src="/vendor/Alpine/alpine.3.13.3.min.js" defer=""></script>
		<script src="/vendor/Enlighter/enlighterjs.min.js"></script>
		<script type="text/javascript">
            EnlighterJS.init('pre.code', 'code', {
            theme: 'droide',
            indent : 4,
            linehover : false,
            textOverflow: 'scroll',
            toolbarTop: '',
            toolbarBottom: ''
        });
        
		</script>
		<script src="/vendor/rp/rpbar-1.0.js"></script>
		<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JQ44ZR47YX"></script>
		<script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-JQ44ZR47YX');
    
		</script>
	</body>
</html>